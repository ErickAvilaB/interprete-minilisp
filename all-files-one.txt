=== File: Lex.x ===
{
module Lex (Token(..), lexer) where
import Data.Char (isSpace)
}

%wrapper "basic"

$white  = [\x20\x09\x0A\x0D\x0C\x0B]
$digit  = 0-9
$letter = [A-Za-z_]
$idrest = [A-Za-z0-9_]

tokens :-

  -- comentarios estilo Lisp
  ";" [^\n]*                 ;

  -- espacios
  $white+                    ;

  -- paréntesis / corchetes / coma
  \(                         { \_ -> TokenPA }
  \)                         { \_ -> TokenPC }
  \[                         { \_ -> TokenBRA }
  \]                         { \_ -> TokenKET }
  \,                         { \_ -> TokenComma }

  -- operadores aritméticos
  \+                         { \_ -> TokenPlus }
  \-                         { \_ -> TokenMinus }
  \*                         { \_ -> TokenTimes }
  \/                         { \_ -> TokenDiv }

  -- comparadores
  ">="                       { \_ -> TokenGeq }
  "<="                       { \_ -> TokenLeq }
  "!="                       { \_ -> TokenNeq }
  "="                        { \_ -> TokenEq }
  "<"                        { \_ -> TokenLt }
  ">"                        { \_ -> TokenGt }

  -- palabras clave
  not                        { \_ -> TokenNot }
  fst                        { \_ -> TokenFst }
  snd                        { \_ -> TokenSnd }
  head                       { \_ -> TokenHead }
  tail                       { \_ -> TokenTail }
  nil                        { \_ -> TokenNil }

  letrec                     { \_ -> TokenLetRec }
  let\*                      { \_ -> TokenLetStar }
  let                        { \_ -> TokenLet }
  lambda                     { \_ -> TokenLambda }
  if0                        { \_ -> TokenIf0 }
  if                         { \_ -> TokenIf }
  cond                       { \_ -> TokenCond }
  else                       { \_ -> TokenElse }

  add1                       { \_ -> TokenAdd1 }
  sub1                       { \_ -> TokenSub1 }
  sqrt                       { \_ -> TokenSqrt }
  expt                       { \_ -> TokenExpt }

  "#t"                       { \_ -> TokenBool True }
  "#f"                       { \_ -> TokenBool False }

  $digit+                    { \s -> TokenNum (read s) }
  $letter$idrest*            { \s -> TokenId s }

  .                          { \s -> error ("Lexical error: caracter no reconocido = "
                                         ++ show s
                                         ++ " | codepoints = "
                                         ++ show (map fromEnum s)) }

{
data Token
  = TokenId String
  | TokenNum Int
  | TokenBool Bool
  -- parens / brackets / comma
  | TokenPA | TokenPC | TokenBRA | TokenKET | TokenComma
  -- arithmetic
  | TokenPlus | TokenMinus | TokenTimes | TokenDiv
  -- comparators
  | TokenEq | TokenLt | TokenGt | TokenLeq | TokenGeq | TokenNeq
  -- keywords / builtins
  | TokenNot | TokenFst | TokenSnd | TokenHead | TokenTail | TokenNil
  | TokenLet | TokenLetStar | TokenLetRec
  | TokenIf0 | TokenIf | TokenLambda
  | TokenCond | TokenElse
  | TokenAdd1 | TokenSub1 | TokenSqrt | TokenExpt
  deriving (Show)

normalizeSpaces :: String -> String
normalizeSpaces = map (\c -> if isSpace c && c /= '\n' then '\x20' else c)

lexer :: String -> [Token]
lexer = alexScanTokens . normalizeSpaces
}


=== File: Parser.y ===
{
module Parser where
import Lex (Token(..), lexer)
}

%name parse
%tokentype { Token }
%error { parseError }

%token
  var       { TokenId $$ }
  int       { TokenNum $$ }
  bool      { TokenBool $$ }

  '('       { TokenPA }
  ')'       { TokenPC }
  '['       { TokenBRA }
  ']'       { TokenKET }
  ','       { TokenComma }

  '+'       { TokenPlus }
  '-'       { TokenMinus }
  '*'       { TokenTimes }
  '/'       { TokenDiv }

  '='       { TokenEq }
  '<'       { TokenLt }
  '>'       { TokenGt }
  "<="      { TokenLeq }
  ">="      { TokenGeq }
  "!="      { TokenNeq }

  "not"     { TokenNot }
  fst       { TokenFst }
  snd       { TokenSnd }
  head      { TokenHead }
  tail      { TokenTail }
  nil       { TokenNil }

  let       { TokenLet }
  "let*"    { TokenLetStar }
  letrec    { TokenLetRec }

  if0       { TokenIf0 }
  if        { TokenIf }
  lambda    { TokenLambda }

  cond      { TokenCond }
  else      { TokenElse }

  add1      { TokenAdd1 }
  sub1      { TokenSub1 }
  sqrt      { TokenSqrt }
  expt      { TokenExpt }

%%

-- Elementos básicos
SASA
  : var                                   { IdS $1 }
  | int                                   { NumS $1 }
  | bool                                  { BooleanS $1 }
  | nil                                   { NilS }

  -- pares y proyecciones
  | '(' SASA ',' SASA ')'                 { PairS $2 $4 }
  | '(' fst SASA ')'                      { FstS $3 }
  | '(' snd SASA ')'                      { SndS $3 }

  -- head/tail como alias de fst/snd
  | '(' head SASA ')'                     { FstS $3 }
  | '(' tail SASA ')'                     { SndS $3 }

  -- listas por corchetes
  | '[' ']'                               { ListS [] }
  | '[' ListElems ']'                     { ListS $2 }

  -- if / if0
  | '(' if SASA SASA SASA ')'             { IfS  $3 $4 $5 }
  | '(' if0 SASA SASA SASA ')'            { If0S $3 $4 $5 }

  -- cond
  | '(' cond Clauses '[' else SASA ']' ')' { CondS $3 $6 }


  -- operadores variádicos aritméticos
  | '(' '+'  SASA SASA MoreS ')'          { PrimNS Plus   ($3:$4:$5) }
  | '(' '-'  SASA SASA MoreS ')'          { PrimNS Minus  ($3:$4:$5) }
  | '(' '*'  SASA SASA MoreS ')'          { PrimNS Times  ($3:$4:$5) }
  | '(' '/'  SASA SASA MoreS ')'          { PrimNS Div    ($3:$4:$5) }

  -- comparadores variádicos
  | '(' '='  SASA SASA MoreS ')'          { PrimNS Eql    ($3:$4:$5) }
  | '(' '<'  SASA SASA MoreS ')'          { PrimNS Lt     ($3:$4:$5) }
  | '(' '>'  SASA SASA MoreS ')'          { PrimNS Gt     ($3:$4:$5) }
  | '(' "<=" SASA SASA MoreS ')'          { PrimNS Leq    ($3:$4:$5) }
  | '(' ">=" SASA SASA MoreS ')'          { PrimNS Geq    ($3:$4:$5) }
  | '(' "!=" SASA SASA MoreS ')'          { PrimNS Neq    ($3:$4:$5) }

  -- unarias / binarias especializadas
  | '(' "not" SASA ')'                    { NotS $3 }
  | '(' add1 SASA ')'                     { Add1S $3 }
  | '(' sub1 SASA ')'                     { Sub1S $3 }
  | '(' sqrt SASA ')'                     { SqrtS $3 }
  | '(' expt SASA SASA ')'                { ExptS $3 $4 }

  -- let / let* / letrec
  | '(' let Bindings SASA ')'             { LetManyS $3 $4 }
  | '(' "let*" Bindings SASA ')'          { LetStarManyS $3 $4 }
  | '(' letrec '(' var SASA ')' SASA ')'  { LetRecS $4 $5 $7 }

  -- lambda variádica y aplicación múltiple
  | '(' lambda '(' Params ')' SASA ')'    { FunManyS $4 $6 }
  | '(' SASA Args ')'                     { AppManyS $2 $3 }


-- Cláusulas de cond: (c1 t1) (c2 t2) ...
Clauses
  : '(' SASA SASA ')'                     { [($2,$3)] }
  | '(' SASA SASA ')' Clauses             { ($2,$3) : $5 }

-- Lista de más argumentos (≥ 0), usada para variádicos con al menos 2
MoreS
  :                                      { [] }
  | SASA MoreS                           { $1 : $2 }

-- Lista de expresiones (≥ 1) para aplicación
Args
  : SASA                                 { [$1] }
  | SASA Args                            { $1 : $2 }

-- Parámetros (≥1)
Params
  : var                                  { [$1] }
  | var Params                           { $1 : $2 }

-- Bindings ((x e) (y e) ...)
Bindings
  : '(' ')'                              { [] }
  | '(' BindList ')'                     { $2 }

BindList
  : '(' var SASA ')'                     { [($2,$3)] }
  | '(' var SASA ')' BindList            { ($2,$3) : $5 }

-- Listas por corchetes [e1, e2, ...]
ListElems
  : SASA                                 { [$1] }
  | SASA ',' ListElems                   { $1 : $3 }


{
parseError :: [Token] -> a
parseError _ = error "Parse error"

-- Superficie (SASA)
data SASA
  = IdS String
  | NumS Int
  | BooleanS Bool
  | NilS
  | PairS SASA SASA
  | FstS SASA
  | SndS SASA
  | ListS [SASA]

  | NotS SASA
  | Add1S SASA | Sub1S SASA | SqrtS SASA | ExptS SASA SASA

  | PrimNS PrimTag [SASA]     -- variádicos: + - * / = < > <= >= !=

  | LetManyS [(String,SASA)] SASA
  | LetStarManyS [(String,SASA)] SASA
  | LetRecS String SASA SASA

  | If0S SASA SASA SASA
  | IfS  SASA SASA SASA

  | CondS [(SASA,SASA)] SASA

  | FunManyS [String] SASA
  | AppManyS SASA [SASA]
  deriving (Show)

data PrimTag = Plus | Minus | Times | Div | Eql | Lt | Gt | Leq | Geq | Neq | Sqrt | Expt
  deriving (Show, Eq)
}


=== File: Desugar.hs ===
module Desugar where

-- Importamos Parser cualificado para usar su PrimTag y constructores (Plus, Minus, ...),
-- y al mismo tiempo traer los constructores de SASA sin colisiones.
import Parser hiding (PrimTag(..))
import qualified Parser as P

--------------------------------------------------------------------------------
-- Núcleo (ASA)
--------------------------------------------------------------------------------

-- ASA: core del lenguaje tras desazucarado
data ASA
  = Id String
  | Num Int
  | Boolean Bool
  | Nil
  | Pair ASA ASA
  | Fst ASA
  | Snd ASA

  -- Primitivas variádicas (se mantienen como lista en el núcleo)
  | PrimN P.PrimTag [ASA]

  | Not ASA
  | If0 ASA ASA ASA
  | If  ASA ASA ASA

  -- El núcleo es de lambdas unarias; lambdas variádicas se currifican
  | Fun String ASA
  | App ASA ASA
  deriving (Show)

--------------------------------------------------------------------------------
-- Forma para evaluar (ASAValues)
--------------------------------------------------------------------------------

data ASAValues
  = IdV String
  | NumV Int
  | BooleanV Bool
  | NilV
  | PairV ASAValues ASAValues
  | FstV ASAValues
  | SndV ASAValues

  | PrimNV P.PrimTag [ASAValues]  -- variádicos listados

  | NotV ASAValues
  | If0V ASAValues ASAValues ASAValues
  | IfV  ASAValues ASAValues ASAValues

  | FunV String ASAValues
  | ExprV ASAValues [(String, ASAValues)]
  | ClosureV String ASAValues [(String, ASAValues)]
  | AppV ASAValues ASAValues
  deriving (Show)

--------------------------------------------------------------------------------
-- Azúcar (SASA) → Núcleo (ASA)
--------------------------------------------------------------------------------

desugar :: SASA -> ASA
-- básicos
desugar (IdS i)                 = Id i
desugar (NumS n)                = Num n
desugar (BooleanS b)            = Boolean b

-- nil y pares / listas
desugar NilS                    = Nil
desugar (PairS a b)             = Pair (desugar a) (desugar b)
desugar (FstS e)                = Fst (desugar e)
desugar (SndS e)                = Snd (desugar e)
desugar (ListS xs)              = foldr (\e acc -> Pair (desugar e) acc) Nil xs

-- unarias especiales y not
desugar (NotS e)                = Not (desugar e)
desugar (Add1S e)               = PrimN P.Plus  [desugar e, Num 1]
desugar (Sub1S e)               = PrimN P.Minus [desugar e, Num 1]
desugar (SqrtS e)               = PrimN P.Sqrt  [desugar e]
desugar (ExptS a b)             = PrimN P.Expt  [desugar a, desugar b]

-- variádicos (+ - * / = < > <= >= !=)
desugar (PrimNS t xs)           = PrimN t (map desugar xs)

-- if / if0
desugar (IfS  c t e)            = If  (desugar c) (desugar t) (desugar e)
desugar (If0S c t e)            = If0 (desugar c) (desugar t) (desugar e)

-- [(SASA,SASA)] SASA donde [(c1,t1), (c2,t2), ...] es la lista de condiciones y sus cuerpos, y SASA es el else
desugar (CondS clauses elseBody) =
  foldr (\(c,t) acc -> If (desugar c) (desugar t) acc) (desugar elseBody) clauses

-- let paralelo: ((lambda (x y ...) body) e1 e2 ...)
desugar (LetManyS binds body)   =
  let (ps, es) = unzip binds
   in appMany (funMany ps (desugar body)) (map desugar es)

-- let* secuencial: anidar lets de a uno
desugar (LetStarManyS [] body)  = desugar body
desugar (LetStarManyS ((x,e):xs) body) =
  App (Fun x (desugar (LetStarManyS xs body))) (desugar e)

-- letrec como en tu base, vía Z y lambda variádica singleton
desugar (LetRecS p v c)         =
  desugar (LetManyS [(p, AppManyS (IdS "Z") [FunManyS [p] v])] c)

-- lambdas variádicas → currificadas
desugar (FunManyS ps body)      = funMany ps (desugar body)

-- aplicación múltiple → aplicaciones anidadas
desugar (AppManyS f args)       = appMany (desugar f) (map desugar args)

--------------------------------------------------------------------------------
-- Helpers (azúcar del núcleo)
--------------------------------------------------------------------------------

-- f a1 a2 ... an  ==  (...((f a1) a2)...) an
appMany :: ASA -> [ASA] -> ASA
appMany = foldl App

-- (lambda (x1 x2 ... xn) body)  ==  (lambda x1 (lambda x2 ... (lambda xn body)...))
funMany :: [String] -> ASA -> ASA
funMany ps body = foldr (\p acc -> Fun p acc) body ps

--------------------------------------------------------------------------------
-- Núcleo (ASA) → Forma evaluable (ASAValues)
--------------------------------------------------------------------------------

desugarV :: ASA -> ASAValues
desugarV (Id i)          = IdV i
desugarV (Num n)         = NumV n
desugarV (Boolean b)     = BooleanV b
desugarV Nil             = NilV
desugarV (Pair a b)      = PairV (desugarV a) (desugarV b)
desugarV (Fst e)         = FstV (desugarV e)
desugarV (Snd e)         = SndV (desugarV e)

desugarV (PrimN t xs)    = PrimNV t (map desugarV xs)

desugarV (Not e)         = NotV (desugarV e)
desugarV (If0 c t e)     = If0V (desugarV c) (desugarV t) (desugarV e)
desugarV (If  c t e)     = IfV  (desugarV c) (desugarV t) (desugarV e)
desugarV (Fun p c)       = FunV p (desugarV c)
desugarV (App f a)       = AppV (desugarV f) (desugarV a)


=== File: MiniLisp.hs ===
module REPL where

import Lex
import Parser
import Desugar
import Interp

-- Combinador Z (orden aplicativa / ansiosa)
combinadorZ :: String
combinadorZ =
  "(lambda (f)                                   \
  \  ((lambda (x)                                \
  \      (f (lambda (v) ((x x) v))))             \
  \   (lambda (x)                                \
  \      (f (lambda (v) ((x x) v))))))"

-- Valor de Z ya evaluado en entorno vacío
z :: ASAValues
z =
  let sasa = parse (lexer combinadorZ)
      asa  = desugar sasa
  in interp (desugarV asa) []

--------------------------------------------------------------------------------
-- Pretty-printer (muestra listas como [a, b, c] y pares como (a . d))
--------------------------------------------------------------------------------

saca :: ASAValues -> String
saca (NumV n)           = show n
saca (BooleanV True)    = "#t"
saca (BooleanV False)   = "#f"
saca NilV               = "[]"
saca (PairV a d)        = case toList (PairV a d) of
                            Just xs -> "[" ++ joinWith ", " (map saca xs) ++ "]"
                            Nothing -> "(" ++ saca a ++ " . " ++ saca d ++ ")"
saca (ClosureV _ _ _)   = "#<procedure>"
saca _                  = "#<valor>"

toList :: ASAValues -> Maybe [ASAValues]
toList NilV                 = Just []
toList (PairV x xs)         = do
  rest <- toList xs
  pure (x : rest)
toList _                    = Nothing

joinWith :: String -> [String] -> String
joinWith _   []     = ""
joinWith _   [x]    = x
joinWith sep (x:xs) = x ++ sep ++ " " ++ joinWith sep xs

--------------------------------------------------------------------------------
-- REPL y helpers
--------------------------------------------------------------------------------

-- Entorno inicial: ligamos Z; alias Y -> Z opcional
prelude :: Env
prelude = [("Z", z), ("Y", z)]

-- Evalúa una cadena fuente en el prelude y devuelve el valor
evalString :: String -> ASAValues
evalString src =
  let toks = lexer src
      sasa = parse toks
      asa  = desugar sasa
  in  interp (desugarV asa) prelude

-- REPL simple (una forma por línea)
repl :: IO ()
repl = do
  putStr "Mini-Lisp> "
  line <- getLine
  if line == "(exit)" || line == ":q"
    then putStrLn "Bye."
    else do
      putStrLn $ saca (evalString line)
      repl

-- Ejecuta REPL
run :: IO ()
run = do
  putStrLn "Mini-Lisp REPL"
  repl

-- Helper para probar rápidamente expresiones
test :: String -> IO ()
test x = putStrLn $ saca (evalString x)

--------------------------------------------------------------------------------
-- Pruebas sugeridas (puedes invocarlas en GHCi)
--------------------------------------------------------------------------------

-- Aritmética variádica
testPlus    = test "(+ 1 2 3 4)"           -- 10
testMinus   = test "(- 10 3 2)"            -- 5
testTimes   = test "(* 3 4 5)"             -- 60
testDiv     = test "(/ 40 2 4)"            -- 5

-- Unarias
testAdd1    = test "(add1 5)"              -- 6
testSub1    = test "(sub1 0)"              -- -1
testSqrt    = test "(sqrt 10)"             -- 3 (floor)
testExpt    = test "(expt 2 10)"           -- 1024

-- Comparaciones variádicas (sobre enteros)
testLt      = test "(< 2 5 9)"             -- #t
testGeq     = test "(>= 9 9 1)"            -- #t
testEq      = test "(= 4 4 4)"             -- #t
testNeq     = test "(!= 1 2 3)"            -- #t

-- Pares y listas
testPair    = test "(fst (1, #t))"         -- 1
testList    = test "[1, 2, 3]"             -- [1, 2, 3]
testHead    = test "(head [1, 2, 3])"      -- 1
testTail    = test "(tail [1, 2, 3])"      -- [2, 3]

-- let / let* variádicos
testLetPar  = test "(let ((x 3) (y (+ x 1))) (+ x y))"
testLetSeq  = test "(let* ((x 3) (y (+ x 1))) (+ x y))" -- 7

-- Lambda variádica y aplicación múltiple
testLambda  = test "((lambda (x y z) (+ x y z)) 1 2 3)" -- 6

-- if e if0
testIf      = test "(if #t 1 2)"           -- 1
testIf0     = test "(if0 0 1 2)"           -- 1

-- cond
testCond1   = test "(cond ([#f 1]) [else 2])"                          -- 2
testCond2   = test "(cond ([(< 2 5) 1]) [(> 2 5) 2] [else 3])"         -- 1
testCond3   = test "(let ((x 0)) (cond ([(< x 0) (- 0 x)]) [(= x 0) 0] [else x]))" -- 0

-- letrec vía Z
testFact    = test "(letrec (fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1)))))) (fact 5))" -- 120


=== File: Interp.hs ===
module Interp where

import qualified Parser as P
import Desugar

-- Entorno léxico
type Env = [(String, ASAValues)]

--------------------------------------------------------------------------------
-- Paso-pequeño (call-by-value / ansioso)
--------------------------------------------------------------------------------

smallStep :: ASAValues -> Env -> (ASAValues, Env)

-- Identificadores y literales
smallStep (IdV i) env                   = (lookupEnv i env, env)
smallStep (NumV n) env                  = (NumV n, env)
smallStep (BooleanV b) env              = (BooleanV b, env)
smallStep NilV env                      = (NilV, env)

-- Pares
smallStep (PairV v w) env
  | isValueV v && isValueV w            = (PairV v w, env)
smallStep (PairV v w) env
  | isValueV v                          = let (w',_) = smallStep w env in (PairV v w', env)
  | otherwise                           = let (v',_) = smallStep v env in (PairV v' w, env)

-- Proyecciones
smallStep (FstV p) env
  | isValueV p =
      case p of
        PairV v _ -> (v, env)
        _         -> runtimeError "fst espera un par"
  | otherwise   = let (p',_) = smallStep p env in (FstV p', env)

smallStep (SndV p) env
  | isValueV p =
      case p of
        PairV _ w -> (w, env)
        _         -> runtimeError "snd espera un par"
  | otherwise   = let (p',_) = smallStep p env in (SndV p', env)

-- Booleanas
smallStep (NotV v) env
  | isValueV v =
      case v of
        BooleanV b -> (BooleanV (not b), env)
        _          -> runtimeError "not espera booleano"
  | otherwise   = let (v',_) = smallStep v env in (NotV v', env)

-- Condicionales
smallStep (IfV c t e) env
  | isValueV c =
      case c of
        BooleanV True  -> (t, env)
        BooleanV False -> (e, env)
        _              -> runtimeError "if espera condición booleana"
  | otherwise   = let (c',_) = smallStep c env in (IfV c' t e, env)

smallStep (If0V c t e) env
  | isValueV c =
      case c of
        NumV 0 -> (t, env)
        NumV _ -> (e, env)
        _      -> runtimeError "if0 espera entero"
  | otherwise   = let (c',_) = smallStep c env in (If0V c' t e, env)

-- Primitivas variádicas
smallStep (PrimNV tag vs) env
  | all isValueV vs                     = (evalPrimN tag vs, env)
  | otherwise                           = let (vs',_) = stepFirst vs env in (PrimNV tag vs', env)

-- Lambdas / clausuras / aplicación (como en tu base)
smallStep (FunV p c) env                = (ClosureV p c env, env)

smallStep (AppV cv@(ClosureV p b env') a) env
  | isValueV a                          = (ExprV b ((p, a) : env'), env)
  | otherwise                           = let (a',_) = smallStep a env in (AppV cv a', env)

smallStep (AppV f a) env                = let (f',_) = smallStep f env in (AppV f' a, env)

-- ExprV: avanza dentro del entorno interno
smallStep (ExprV v env') env
  | isValueV v                          = (v, env)
  | otherwise                           = let (e1, _) = smallStep v env' in (ExprV e1 env', env)

--------------------------------------------------------------------------------
-- Interpretación total
--------------------------------------------------------------------------------

interp :: ASAValues -> Env -> ASAValues
interp e env
  | isValueV e = e
  | otherwise  =
      let (e', env') = smallStep e env
       in interp e' env'

--------------------------------------------------------------------------------
-- Predicados de valor y auxiliares
--------------------------------------------------------------------------------

isValueV :: ASAValues -> Bool
isValueV (NumV _)           = True
isValueV (BooleanV _)       = True
isValueV NilV               = True
isValueV (PairV v w)        = isValueV v && isValueV w
isValueV (ClosureV _ _ _)   = True
isValueV _                  = False

lookupEnv :: String -> Env -> ASAValues
lookupEnv i [] = runtimeError ("Variable " ++ i ++ " no encontrada")
lookupEnv i ((j, v) : env)
  | i == j    = v
  | otherwise = lookupEnv i env

-- Avanza la primera subexpresión no valor de una lista de argumentos
stepFirst :: [ASAValues] -> Env -> ([ASAValues], Env)
stepFirst [] env = ([], env)
stepFirst (x:xs) env
  | isValueV x = let (xs', env') = stepFirst xs env in (x:xs', env')
  | otherwise  = let (x', env')  = smallStep x env in (x':xs, env')

runtimeError :: String -> a
runtimeError msg = error ("Runtime error: " ++ msg)

--------------------------------------------------------------------------------
-- Primitivas variádicas y helpers numéricos
--------------------------------------------------------------------------------

-- Convierten y validan enteros
nums :: [ASAValues] -> [Int]
nums = map num
  where
    num (NumV n) = n
    num _        = runtimeError "se esperaba entero"

safeDiv :: Int -> Int -> Int
safeDiv _ 0 = runtimeError "división por cero"
safeDiv a b = a `div` b

-- Cadena de comparaciones sobre enteros
boolChain :: (Int -> Int -> Bool) -> [ASAValues] -> ASAValues
boolChain _ []       = BooleanV True
boolChain _ [_]      = BooleanV True
boolChain op vs      =
  let ns = nums vs
  in BooleanV (and (zipWith op ns (tail ns)))

allEqual :: Eq a => [a] -> Bool
allEqual []     = True
allEqual (x:xs) = all (== x) xs

allDistinct :: Ord a => [a] -> Bool
allDistinct []     = True
allDistinct (x:xs) = notElem x xs && allDistinct xs

-- Evaluación de primitivas
evalPrimN :: P.PrimTag -> [ASAValues] -> ASAValues

-- Aritmética (+ - * /) sobre enteros (≥ 2 args)
evalPrimN P.Plus  vs = NumV (foldl1 (+) (nums vs))
evalPrimN P.Minus vs = NumV (foldl1 (-) (nums vs))
evalPrimN P.Times vs = NumV (foldl1 (*) (nums vs))
evalPrimN P.Div   vs = NumV (foldl1 safeDiv (nums vs))

-- sqrt (exactamente 1 arg)
evalPrimN P.Sqrt [v]   = NumV (floor (sqrt (fromIntegral (head (nums [v])) :: Double)))
evalPrimN P.Sqrt _     = runtimeError "sqrt espera 1 argumento"

-- expt (exactamente 2 args)
evalPrimN P.Expt [a,b] =
  case nums [a,b] of
    [x,y] -> NumV (x ^ y)
    _     -> runtimeError "expt espera 2 argumentos"
evalPrimN P.Expt _     = runtimeError "expt espera 2 argumentos"

-- Comparaciones variádicas (≥ 2), cadena
evalPrimN P.Lt  vs = boolChain (<)  vs
evalPrimN P.Gt  vs = boolChain (>)  vs
evalPrimN P.Leq vs = boolChain (<=) vs
evalPrimN P.Geq vs = boolChain (>=) vs

-- Igualdad / desigualdad variádicas (≥ 2), enteros
evalPrimN P.Eql vs = BooleanV (allEqual (nums vs))
evalPrimN P.Neq vs = BooleanV (allDistinct (nums vs))


